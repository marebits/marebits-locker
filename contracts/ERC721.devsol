// SPDX-License-Identifier: LicenseRef-DSPL
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

interface IERC721 is IERC721Enumerable, IERC721Metadata {
	/// @notice Thrown when caller is not the owner of the token or caller is not approved
	error InsufficientPermissions();

	/// @notice Thrown when attempting to use a zero address when not allowed
	error InvalidZeroAddress();

	/// @notice Thrown when the token `tokenId` does not exist
	/// @param tokenId given
	error NonexistentToken(uint256 tokenId);

	/**
	 * @notice Thrown when attempting to access an index that is out of bounds
	 * @param index that is out of bounds
	 * @param min lower bound
	 * @param max upper bound
	 */
	error IndexOutOfBounds(uint256 index, uint256 min, uint256 max);

	/// @notice Thrown when attempting to transfer a token between the same address
	error SendToSelf();

	/// @notice Thrown when caller is attempting to approve themselves
	error SelfApproval();

	/// @notice Thrown when the token `tokenId` already exists
	/// @param tokenId that already exists
	error TokenAlreadyExists(uint256 tokenId);

	/// @notice Thrown when the address `receiver` cannot receive tokens because they do not implement {ERC721Receiver}
	/// @param receiver contract address that does not implement {ERC721Receiver}
	error UnableToReceiveTokens(address receiver);
}

library TokenOwners {
	using TokenOwners for Data;

	struct Data {
		mapping(address => uint256) _balances;
		mapping(address => mapping(address => bool)) _operatorApprovals;
		mapping(address => mapping(uint256 => uint256)) _ownedTokens;
		mapping(uint256 => uint256) _ownedTokensIndex;
	}

	function balanceOf(Data storage self, address owner) internal view returns (uint256) { return self._balances[owner]; }

	function decrementBalance(Data storage self, address owner) internal { self._balances[owner]--; }

	function getOwnerByIndex(Data storage self, address owner, uint256 index) internal view returns (uint256) { return self._ownedTokens[owner][index]; }

	function incrementBalance(Data storage self, address owner) internal { self._balances[owner]++; }

	function isApproved(Data storage self, address owner, address operator) internal view returns (bool) { return self._operatorApprovals[owner][operator]; }

	function setApproval(Data storage self, address owner, address operator, bool isApproval) internal { self._operatorApprovals[owner][operator] = isApproval; }

	function transfer(Data storage self, address from, address to) internal {
		self.decrementBalance(from);
		self.incrementBalance(to);
	}
}

library Tokens {
	struct Data {
		uint256[] _allTokens;
		mapping(uint256 => uint256) _allTokensIndex;
		mapping(uint256 => address) _owners;
		mapping(uint256 => address) _tokenApprovals;
	}

	function approve(Data storage self, uint256 tokenId, address to) internal { self._tokenApprovals[tokenId] = to; }

	function exists(Data storage self, uint256 tokenId) internal view returns (bool) { self._owners[tokenId] != address(0); }

	function getApproved(Data storage self, uint256 tokenId) internal view returns (address) { return self._tokenApprovals[tokenId]; }

	function ownerOf(Data storage self, uint256 tokenId) internal view returns (address) { return self._owners[tokenId]; }

	function remove(Data storage self, uint256 tokenId) internal { delete self._owners[tokenId]; }

	function transfer(Data storage self, uint256 tokenId, address to) internal { self._owners[tokenId] = to; }
}

import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/introspection/ERC165.sol";

abstract contract ERC721 is Context, ERC165, IERC721 {
	using Address for address;
	using Strings for uint256;
	using TokenOwners for TokenOwners.Data;
	using Tokens for Tokens.Data;

	TokenOwners.Data private _tokenOwners;
	Tokens.Data private _tokens;

	/// @dev Caller must be either the owner of token `tokenId` or approved to send `tokenId`
	/// @param tokenId to check
	modifier approvedOrOwner(uint256 tokenId) {
		if (!_isApprovedOrOwner(_msgSender(), tokenId)) {
			revert InsufficientPermissions();
		}
		_;
	}

	modifier boundedIndex(uint256 index, uint256 min, uint256 max) {
		if (index < min || index > max) {
			revert IndexOutOfBounds(index, min, max);
		}
		_;
	}

	/**
	 * @dev Checks whether the address `to` has properly implemented {ERC721Receiver}
	 * @param from address sending the token
	 * @param to address receiving the token
	 * @param tokenId of token being sent
	 * @param data to pass to the `onERC721Received` function
	 */
	modifier isValidReceiver(address from, address to, uint256 tokenId, bytes memory data) {
		_;

		if (!_checkOnERC721Received(from, to, tokenId, data)) {
			revert UnableToReceiveTokens(to);
		}
	}

	/// @dev the address `toCheck` must not be the zero address
	/// @param toCheck address to check
	modifier nonZeroAddress(address toCheck) {
		if (toCheck == address(0)) {
			revert InvalidZeroAddress();
		}
	}

	/// @dev Address `from` must be the owner of token `tokenId`
	/// @param from address
	/// @param tokenId of the token
	modifier onlyOwner(address from, uint256 tokenId) {
		if (from != ownerOf(tokenId)) {
			revert InsufficientPermissions();
		}
		_;
	}

	/// @dev token `tokenId` must already exist
	/// @param tokenId to check
	modifier tokenExists(uint256 tokenId) {
		if (!_exists(tokenId)) {
			revert NonexistentToken(tokenId);
		}
		_;
	}

	/// @dev Approve `to` to operate on `tokenId`
	/// Emits an {Approval} event
	function _approve(address to, uint256 tokenId) internal virtual {
		_tokens.approve(tokenId, to);
		emit Approval(ownerOf(tokenId), to, tokenId);
	}

	/// @dev Base URI for computing {tokenURI}.  If set, the resulting URI for each token will be the concatenation of the `baseURI` and the `tokenId`.
	function _baseURI() internal view virtual returns (string memory) { return ""; }

	/// @dev Hook that is called before any token transfer.  This includes minting and burning.
	function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { /* this space intentionally left blank */ }

	/// @dev Destroys `tokenId`.  The approval is cleared when the token is burned.
	/// Emits a {Transfer} event
	function _burn(uint256 tokenId) internal virtual {
		_beforeTokenTransfer(owner, address(0), tokenId);
		_approve(address(0), tokenId);
		_tokenOwners.decrementBalance(owner);
		_tokens.remove(tokenId);
		emit Transfer(owner, address(0), tokenId);
	}

	/**
	 * @dev Internal function to invole {IERC721REceiver~onERC721Received} on a target address.  The call is not executed if the target address is not a contract.
	 * @param from address representing the previous owner of the given token ID
	 * @param to target address that will receive the tokens
	 * @param tokenId uint256 ID of the token to be transferred
	 * @param data bytes optional data to send along with the call
	 * @return bool whether the call correctly returned the expected magic value
	 */
	function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private returns (bool) {
		if (to.isContract()) {
			try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {
				return retval == IERC721Receiver.onERC721Received.selector;
			} catch (bytes memory reason) {
				if (reason.length == 0) {
					revert UnableToReceiveTokens(to);
				} else {
					assembly {
						revert(add(32, reason), mload(reason))
					}
				}
			}
		} else {
			return true;
		}
	}

	/// @dev Returns whether `tokenId` exists
	function _exists(uint256 tokenId) internal view virtual returns (bool) { return _tokens.exists(tokenId); }

	/// @dev Returns whether `spender` is allowed to manager `tokenId`
	function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual tokenExists(tokenId) returns (bool) {
		return (spender == ownerOf(tokenId) || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
	}

	/// @dev Mints `tokenId` and transfers it to `to`
	/// Emits a {Transfer} event
	function _mint(address to, uint256 tokenId) internal virtual nonZeroAddress(to) {
		if (_exists(tokenId)) {
			revert TokenAlreadyExists(tokenId);
		}
		_beforeTokenTransfer(address(0), to, tokenId);
		_tokenOwners.incrementBalance(to);
		_tokens.transfer(tokenId, to);
		emit Transfer(address(0), to, tokenId);
	}

	/// @dev Safely mints `tokenId` and transfers it to `to`.
	/// Emits a {Transfer} event.
	function _safeMint(address to, uint256 tokenId) internal virtual { _safeMint(to, tokenId, ""); }

	/// @dev Same as `_safeMint` above, with an additional `data` parameter which is forwarded to `IERC721Receiver~onERC721Received} to contract recipients.
	function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual isValidReceiver(address(0), to, tokenId, data) { _mint(to, tokenId); }

	/// @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked.
	/// `data` is additional data, it has no specified format and it is sent in call to `to`.
	/// Emits a {Transfer} event.
	function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual isValidReceiver(from, to, tokenId, data) { _transfer(from, to, tokenId); }

	/// @dev Approve `operator` to operate on all of `owner` tokens
	/// Emits an {ApprovalForAll} event.
	function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {
		if (owner == operator) {
			revert SelfApproval();
		}
		_tokenOwners.setApproval(owner, operator, approved);
		emit ApprovalForAll(owner, operator, approved);
	}

	/// @dev Transfers `tokenId` from `from` to `to`.  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
	/// Emits a {Transfer} event
	function _transfer(address from, address to, uint256 tokenId) internal virtual onlyOwner(from, tokenId) nonZeroAddress(to) {
		_beforeTokenTransfer(from, to, tokenId);
		_approve(address(0), tokenId);
		_tokenOwners.transfer(from, to);
		_tokens.transfer(tokenId, to);
		emit Transfer(from, to, tokenId);
	}

	/// @inheritdoc IERC721
	function approve(address to, uint256 tokenId) public virtual override {
		if (ownerOf(tokenId) == to) {
			revert SendToSelf();
		} else if (_msgSender() != ownerOf(tokenId) && !isApprovedForAll(ownerOf(tokenId), _msgSender())) {
			revert InsufficientPermissions();
		}
		_approve(to, tokenId);
	}

	/// @inheritdoc IERC721
	function balanceOf(address owner) public view virtual override nonZeroAddress(owner) returns (uint256) { return _tokenOwners.balanceOf(owner); }

	/// @inheritdoc IERC721
	function getApproved(uint256 tokenId) public view virtual override tokenExists(tokenId) returns (address) { return _tokens.getApproved(tokenId); }
	/// @inheritdoc IERC721
	function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) { return _tokenOwners.isApproved(owner, operator); }

	/// @inheritdoc IERC721Metadata
	function name() public view virtual returns (string memory) { return ""; }

	/// @inheritdoc IERC721
	function ownerOf(uint256 tokenId) public view virtual override tokenExists(tokenId) returns (address) { return _tokens.ownerOf(tokenId); }

	/// @inheritdoc IERC721
	function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override { safeTransferFrom(from, to, tokenId, ""); }

	/// @inheritdoc IERC721
	function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override approvedOrOwner(tokenId) { _safeTransfer(from, to, tokenId, data); }

	/// @inheritdoc IERC721
	function setApprovalForAll(address operator, bool approved) public virtual override { _setApprovalForAll(_msgSender(), operator, approved); }

	/**
	* @dev Implementation of the {IERC165} interface.
	* @inheritdoc ERC165
	*/
	function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165) returns (bool) {
		return interfaceId == type(IERC721).interfaceId || 
			interfaceId == type(IERC721Enumerable).interfaceId || 
			interfaceId == type(IERC721Metadata).interfaceId || 
			super.supportsInterface(interfaceId);
	}

	/// @inheritdoc IERC721Metadata
	function symbol() public view virtual returns (string memory) { return ""; }

	/// @inheritdoc IERC721Enumerable
	function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override boundedIndex(index, 0, balanceOf(owner)) returns (uint256) { _tokenOwners.getOwnerByIndex(owner, index); }

	/// @inheritdoc IERC721Metadata
	function tokenURI(uint256 tokenId) public view virtual override tokenExists(tokenId) returns (string memory) {
		return bytes(_baseURI()).length > 0 ? string(abi.encodePacked(_baseURI(), tokenId.toString())) : "";
	}

	/// @inheritdoc IERC721
	function transferFrom(address from, address to, uint256 tokenId) public virtual override approvedOrOwner(tokenId) { _transfer(from, to, tokenId); }
}