// SPDX-License-Identifier: LicenseRef-DSPL
pragma solidity 0.8.10;

// library Uint16Array {
// 	function get(bytes32 self, uint8 index) internal pure returns (uint16 result) {
// 		require(index <= 15);
// 		result = uint16(uint256(uint8(self[index * 2])) << 8);
// 		result += uint16(uint256(uint8(self[index * 2 + 1])));
// 	}

// 	function set(bytes32 self, uint8 index, uint16 value) internal pure returns (bytes32) {
// 		require(index <= 15);
// 		uint256 subtrahend = 16 * uint256(index);
// 		self &= bytes32(uint256(~(0xff << (240 - subtrahend))));
// 		self |= bytes32(uint256(uint256(value) << (240 - subtrahend)));
// 		return self;
// 	}
// }

library Time {
	// using Uint16Array for bytes32;

	struct Components {
		uint64 timestamp;
		uint8 second;
		uint8 minute;
		uint8 hour;
		uint8 day;
		uint8 month;
		uint16 year;
	}

	int64 constant JULIAN_DAY_OFFSET = 2440588; // num of days between Jan 1 4712 BC and Jan 1 1970 AD

	function fromSeconds2(uint64 timestamp) internal pure returns (Components memory components) {
		// first get the date
		// conversion algorithm from Julian days to Gregorian date, as designed by Henry F. Fliegel and Thomas C. Van Flandern https://dl.acm.org/doi/10.1145/364096.364097
		uint64 day = timestamp / 1 days;
		int64 l = int64(day) + 68569 + JULIAN_DAY_OFFSET;
		int64 n = 4 * l / 146097;
		l -= (146097 * n + 3) / 4;
		int64 i = 4000 * (l + 1) / 1461001;
		l -= 1461 * i / 4 + 31;
		int64 j = 80 * l / 2447;
		components.day = uint8(int8(l - 2447 * j / 80));
		l = j / 11;
		components.month = uint8(int8(j + 2 - 12 * l));
		components.year = uint16(int16(100 * (n - 49) + i + l));
		// now get the time
		uint64 sec = timestamp % 1 days;
		components.hour = uint8(sec / 1 hours);
		sec %= 1 hours;
		(components.timestamp, components.minute, components.second) = (timestamp, uint8(sec / 1 minutes), uint8(sec % 1 minutes));
	}

	// bytes32 constant daysByMonth = hex"0000001f003b005a0078009700b500d400f301110130014e016d000000000000";
	// bytes32 constant daysByMonthLeapYear = hex"0000001f003c005b0079009800b600d500f401120131014f016e000000000000";
	// uint64 constant secondsPerHour = 60 * 60;
	// uint64 constant secondsPerDay = 24 * secondsPerHour;
	// // 1970 - 1601 = 369 = 3 * 100 + 17 * 4 + 1 years
	// uint64 constant secondsFrom1601to1970 = (3 * 100 * (365 + 24 / 100) + 17 * 4 * (365 + 1 / 4) + 1 * 365) * secondsPerDay;
	// uint64 constant secondsPerQuadricentennial = 400 * 365.2425 * secondsPerDay;
	// uint64 constant secondsPerCentennial = 100 * (365 + 24 / 100) * secondsPerDay;
	// uint64 constant secondsPerQuadrennial = 4 * (365 + 1 / 4) * secondsPerDay;
	// uint64 constant secondsPerYear = 365 * secondsPerDay;

	// function fromSeconds(uint64 totalSeconds) internal pure returns (Components memory components) {
	// 	components.totalSeconds = totalSeconds;
	// 	uint256 sec;
	// 	uint256 quadricentennials;
	// 	uint256 centennials;
	// 	uint256 quadrennials;
	// 	uint256 annuals;
	// 	bool leap;
	// 	uint256 dayOfTheYear;
	// 	bytes32 daysByMonthThisYear;

	// 	// re-bias from 1970 to 1601, because why not (quadricentennials?)
	// 	sec = totalSeconds + secondsFrom1601to1970;
	// 	// remove multiples of 400 years, including 97 leap days
	// 	quadricentennials = sec / secondsPerQuadricentennial;
	// 	sec %= secondsPerQuadricentennial;
	// 	// remove multiples of 100 years, including 24 leap days; can't be more than 3 multiples
	// 	centennials = sec / secondsPerCentennial;

	// 	if (centennials > 3) {
	// 		centennials = 3;
	// 	}
	// 	sec -= centennials * secondsPerCentennial;
	// 	// remove multiples of 4 years, including 1 leap day; can't be more than 24 multiples
	// 	quadrennials = sec / secondsPerQuadrennial;

	// 	if (quadrennials > 24) {
	// 		quadrennials = 24;
	// 	}
	// 	sec -= quadrennials * secondsPerQuadrennial;
	// 	// remove multiples of years, can't be more than 3
	// 	annuals = sec / secondsPerYear;

	// 	if (annuals > 3) {
	// 		annuals = 3;
	// 	}
	// 	sec -= annuals * secondsPerYear;
	// 	// calculate the year and see if it's leap
	// 	components.year = uint16(1601 + quadricentennials * 400 + centennials * 100 + quadrennials * 4 + annuals);
	// 	leap = components.year % 4 == 0 && (components.year % 100 > 0 || components.year % 400 == 0);
	// 	// calculate the day of the year and time
	// 	dayOfTheYear = sec / secondsPerDay;
	// 	sec %= secondsPerDay;
	// 	components.hour = sec / secondsPerHour;
	// 	sec %= secondsPerHour;
	// 	(components.min, components.sec) = (sec / 60, sec % 60);
	// 	// calculate the month
	// 	daysByMonthThisYear = leap ? daysByMonthLeapYear : daysByMonth;

	// 	for ((components.day, components.month) = (1, 1); components.month < 13; components.month++) {
	// 		if (dayOfTheYear < daysByMonthThisYear.get(uint8(components.month))) {
	// 			components.day = dayOfTheYear - daysByMonthThisYear.get(uint8(components.month - 1));
	// 			break;
	// 		}
	// 	}
	// }
}

contract Test {
	function tester(uint64 secs) public pure returns (Time.Components memory) {
		return Time.fromSeconds2(secs);
	}
}